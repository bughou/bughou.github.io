---
title: "腾讯面试"
date: 2017-12-20T09:29:11+08:00
---


昨晚面试，暴露了我的一个问题，浮于表面，对基础概念的实现完全没有深入研究。 记录一下面试过程：

# 1. 跳槽多
  面试官坐下来，看我的简历，就说你呆过的公司挺多啊。让我解释一下为啥换了这多公司。于是我开始一家一家的解释离职原因。面试官也没说啥。现在想起来，我应该总结一下，到目前为止呆过5家公司，第一次辞职是上海回成都，第二次是因为自己创业，第三次是因为被朋友挖走了，第四次是因为公司高层斗争不发工资了。

# 2. atoi实现
  我说比较了解C，C相对C++简单很多。面试官说那你用C实现一下字符串转整数。正下笔的时候，发现C的函数定义是怎么样的都想不起来了，窘得不行。赶紧说好多年没写过C、语法都忘了，说用golang实现吧，面试官同意了。开始用golang实现：
```go
func atoi(s string) (result int) {
  d := 1
  for i := 0; i < len(s); i++ {
    d *= 10
    result += s[i] * d
  }
  return
}
```
在写完也没检查立即就给面试官了，纸上字迹比较潦草，就给面试官解说我的思路。正准备说思路，发现不对啊，立即给面试官说，这里不对，应该是从右向左遍历，于是改成下面这样：
```go
func atoi(s string) (result int) {
  d := 1
  for i := len(s) - 1; i >= 0; i++ {
    d *= 10
    result += s[i] * d
  }
  return
}
```
着急忙荒的i++也忘了改成i--了。开始解释我的思路，面试官也没说啥，就说用Golang确实比用C简单很多，然后我说就这个功能来说用golang和用C，应该是一样的，没啥区别，他说C语言里你怎么遍历字符串，我一下想起来，这里取字符串长度用了len，而C没有这个内置方法，确实golang省事不少。后来回去的路上，突然想起来，不对啊， d \*= 10 应该放在循环体的末尾啊，也不知道面试官看出来没有。现在想来，这实现还是有很大问题啊，完全没有错误处理啊。面试的时候想的都是赶紧做完，太仓促了，很多都没考虑到，平时写代码肯定不会忘记错误处理。或许面试官也看出这些问题了，只是没指出来而已，默默在心里做了减分吧。

补充，还有个问题：`s[i] * d` 也忘了减掉 `'0'`了，应该是`(s[i]-'0') * d`啊。下午用C重新实现了一遍：
```c
#include <stdio.h>
#include <stdlib.h>

int Atoi(const char s[]) {
  int len = 0, negative = 0;
  if (s != NULL) {
    switch (s[0]) {
      case '+': s++; break;
      case '-': negative = 1; s++; break;
    }
    while (1) {
      int d = s[len] - '0';
      if (d >= 0 && d <= 9) len++;
      else break;
    }
  }

  int result = 0, base = 1;
  for (int i = len - 1; i >= 0; i--) {
    result += (s[i] - '0') * base;
    base *= 10;
  }

  if (negative) {
    result = -result;
  }

  return result;
}

int main() {
  char* s[] = { "", "123",  "+123", "-123", "123a4", "+123a4", "-123a4", NULL };
  int failed = 0;
  for (int i = 0; s[i] != NULL; i++) {
    int expect = atoi(s[i]);
    int got    = Atoi(s[i]);
    if (got != expect) {
      printf("input: %s, expect: %d, got: %d\n", s[i], expect, got);
      failed++;
    }
  }
  if (failed == 0) {
    printf("all tests passed.\n");
  }
}
```

# 3. golang channel的实现
  面试官问channel是怎样实现的，之前在网上搜了过，大致看了一下，链表+锁，就没深入研究了。我说链表+锁，然后开始扯"Don't communicate by sharing memory; share memory by communicating"这句话的误导性，不要一味的用channel，因为channel也是加锁实现的，channel和锁应该是哪个用起来简单直观，就用哪个。还把share memory说成了share information。
  
  然后面试官问channel的阻塞是怎么实现的。我不知道啊，看channel实现的时候，忘记了看阻塞了，这么重要的。我说不知道，又开始扯网络操作的阻塞是通过epoll实现的。回去后看了channel的实现代码，channel的阻塞，其实是阻塞所在的goroutine，这个原理我是知道的啊，不光是channel，sleep、网络IO也都是通过阻塞所在的goroutine来实现的。但是从来没有对channel的阻塞这么想过，突然被问道，就反应不过来。

  面试官又问哪个系统调用能实现和channel类似的效果，想了想，然后说不知道。回去的路上想起来面试官想问的莫非是管道（pipe）。记得刚开始接触的golang的时候，确实有把这两个做类比，现在用久了，都没有把这两者联系在一起过了。


# 4. make、非make 两种初始化的区别
  然后面试官问，map的make初始化、非make形式的初始化的区别。我一想说make形式的在堆上？非make形式的在栈上？面试官说是否在栈上也要看值得大小吧。我就说不知道了，平时都是看着哪个顺手就用哪个的。回去的路上想，make可以传capacity hint啊，莫非是想问这个区别？

# 5. 聊做过的项目
  然后面试官估计有点失望了，问我“你项目经历还挺多的，是不是一直在做业务，没有做过底层啊？”，我一想，是啊，没做过底层项目啊，就说是的。然后一想不对，我最近不是做了框架吗？赶紧说最近做了个框架。面试官问为啥要自己做，应该是已经有挺好用的开源的了吧？然后我就解释了http标准库没有正则支持、不直观，beego的风格不喜欢，个人喜欢express风格。然后解释了我们框架中基于map的路由比常见的基于数组的路由更优化、还有更直观的模板渲染等。然后面试官说他们和我们不一样，用的路由很简单。

  然后我说框架自带了ELK日志收集等功能，面试官就问为啥要自己写logc日志收集，我就说首先是自己喜欢造轮子，还有当初对logstash基于轮询的日志收集不满意，再加上觉得自己做也很简单，所以就自己做了。面试官说fluentd也是基于轮询的吗，我说fluentd不是基于轮询的，但是我们知道fluentd的时候，logc已经写了一大半了。面试官说如果是他，他会给logstash之类的写一个插件，也不会自己写完整的日志收集。我说都已经有zookeeper了，go社区不是还是实现了自己的etcd吗？如果对一个东西感兴趣，想自己写，就勇敢动手自己写，至少也是一种成长嘛。面试官略表同意。 回来的路上想，其实还有两个重要的原因，一是logstash依赖java，fluentd依赖ruby，我们不想在我们的docker镜像里加入这两个运行时依赖。还有就是当时不太满意kibana没有权限控制，打算自己实现一个基于elasticSearch的日志可视化和监控系统，所以想日志收集也自己写，有更多的控制，方便监控报警等实现。后来kibana用的多了，发现elasticSearch有watch、alerts等功能，慢慢就放弃自己实现日志可视化和监控的想法了。

  然后给面试官说框架实现了基于docker的部署，面试官问日志收集容器是怎么访问到其他容器的日志的。我就说了volume在多个容器间共享存储。

# 6. 结束
  然后面试官就让我回去了。说给领导汇报一下，或者让华仔通知我面试结果。下楼来看，才7点三十多，7点过几分上楼的，还等了会儿，所以面试过程估计也就二十分钟的样子。

# 总结
  上一次面试，还是四年前了。以前的面试也都是问一些各种用法，从来没有被问过底层原理和实现。自己对底层实现没足够了解，浮于表面，所以面试肯定是非常被动的。长期目标：花时间吃透底层实现，让自己更有底气些。

